{
  "$schema": "../../schema/locale.schema.json",
  "locale": "it",
  "category": "cloud.flow",
  "version": "1.0.0",
  "translations": {
    "flow.branch.condition": "Condizione",
    "flow.branch.conditionHint": "Supporta: ==, !=, >, <, >=, <=, contains",
    "flow.branch.conditionPlaceholder": "es. ${step1.count} > 0",
    "flow.branch.false": "Falso",
    "flow.branch.falseDesc": "Quando la condizione e falsa",
    "flow.branch.true": "Vero",
    "flow.branch.trueDesc": "Quando la condizione e vera",
    "flow.end.addMapping": "Aggiungi Output",
    "flow.end.info": "Questo e un nodo terminale - l'esecuzione del workflow termina qui",
    "flow.end.outputMapping": "Mappatura Output",
    "flow.end.outputMappingHint": "Mappa le variabili interne all'output del workflow",
    "flow.end.successMessage": "Messaggio di Successo",
    "flow.end.successMessagePlaceholder": "Messaggio di completamento opzionale",
    "flow.fork.branchCount": "Numero di Rami",
    "flow.fork.branchCountHint": "Tutti i rami vengono eseguiti in parallelo (2-10)",
    "flow.fork.branches": "Rami di Output",
    "flow.fork.info": "Tutti i rami si attivano simultaneamente con gli stessi dati di input",
    "flow.join.cancelPending": "Annulla i Pendenti al Completamento",
    "flow.join.inputCount": "Numero di Input",
    "flow.join.inputs": "Porte di Input",
    "flow.join.strategy": "Strategia di Join",
    "flow.join.strategyAll": "Tutti - Attendi tutti gli input",
    "flow.join.strategyAllHint": "Attende tutti gli input prima di procedere",
    "flow.join.strategyAny": "Qualsiasi - Continua su qualsiasi input",
    "flow.join.strategyAnyHint": "Continua quando arriva qualsiasi input",
    "flow.join.strategyFirst": "Primo - Il primo vince, annulla gli altri",
    "flow.join.strategyFirstHint": "Il primo input vince, annulla i rimanenti",
    "flow.join.timeout": "Timeout",
    "flow.join.timeoutHint": "Tempo massimo di attesa in millisecondi (1s - 1h)",
    "flow.loop.noTarget": "Nessun target del loop impostato",
    "flow.loop.target": "Loop verso:",
    "flow.loop.targetHint": "Connetti un arco di loop per impostare il nodo target",
    "flow.loop.times": "Ripetizioni Loop",
    "flow.loop.timesHint": "Numero di volte da ripetere (1-1000)",
    "flow.loop.timesPlaceholder": "10",
    "flow.merge.inputCount": "Numero di Input",
    "flow.merge.inputCountHint": "Porte di input dinamiche (2-10)",
    "flow.merge.inputs": "Porte di Input",
    "flow.merge.strategy": "Strategia di Merge",
    "flow.merge.strategyAll": "Tutti - Raccogli tutti gli input",
    "flow.merge.strategyAllHint": "Raccoglie tutti gli input in un array",
    "flow.merge.strategyFirst": "Primo - Il primo input vince",
    "flow.merge.strategyFirstHint": "Usa il primo input che arriva",
    "flow.merge.strategyLast": "Ultimo - L'ultimo input vince",
    "flow.merge.strategyLastHint": "Usa l'ultimo input che arriva",
    "flow.subflow.addInput": "Aggiungi Input",
    "flow.subflow.addOutput": "Aggiungi Output",
    "flow.subflow.executionMode": "Modalita di Esecuzione",
    "flow.subflow.inputMapping": "Mappatura Input",
    "flow.subflow.modeAsync": "Asincrono - Esegui e dimentica",
    "flow.subflow.modeAsyncHint": "Avvia il subflow e continua senza attendere",
    "flow.subflow.modeInline": "Inline - Attendi il completamento",
    "flow.subflow.modeInlineHint": "Blocca fino al completamento del subflow, restituisce il risultato",
    "flow.subflow.modeSpawn": "Spawn - Nuova esecuzione, ottieni ID",
    "flow.subflow.modeSpawnHint": "Crea una nuova esecuzione, restituisce immediatamente l'ID di esecuzione",
    "flow.subflow.outputMapping": "Mappatura Output",
    "flow.subflow.timeout": "Timeout (ms)",
    "flow.subflow.workflowRef": "Riferimento Workflow",
    "flow.subflow.workflowRefHint": "ID o percorso del workflow esterno da eseguire",
    "flow.subflow.workflowRefPlaceholder": "workflow_id o percorso",
    "flow.switch.addCase": "Aggiungi Caso",
    "flow.switch.case": "Caso",
    "flow.switch.cases": "Casi Switch",
    "flow.switch.default": "Default",
    "flow.switch.defaultInfo": "I valori non corrispondenti vanno all'output Default",
    "flow.switch.expression": "Espressione",
    "flow.switch.expressionHint": "Valore da confrontare con i casi",
    "flow.switch.expressionPlaceholder": "es. ${step1.status}",
    "flow.switch.label": "Etichetta",
    "flow.switch.labelPlaceholder": "Etichetta di visualizzazione",
    "flow.switch.value": "Valore",
    "flow.switch.valuePlaceholder": "Valore da confrontare",
    "flow.trigger.description": "Descrizione",
    "flow.trigger.descriptionPlaceholder": "Descrizione opzionale di questo trigger",
    "flow.trigger.eventInfo": "Il workflow si avvia quando si verifica l'evento specificato",
    "flow.trigger.eventName": "Nome Evento",
    "flow.trigger.eventNameHint": "Nome dell'evento da ascoltare",
    "flow.trigger.manualInfo": "Il workflow si avvia quando attivato manualmente dall'utente",
    "flow.trigger.schedule": "Espressione Cron",
    "flow.trigger.scheduleHint": "Formato cron standard: minuto ora giorno mese giorno_settimana",
    "flow.trigger.scheduleInfo": "Il workflow viene eseguito automaticamente secondo la pianificazione",
    "flow.trigger.type": "Tipo di Trigger",
    "flow.trigger.typeEvent": "Evento - Ascolta evento",
    "flow.trigger.typeManual": "Manuale - Avviato dall'utente",
    "flow.trigger.typeSchedule": "Pianificato - Basato su Cron",
    "flow.trigger.typeWebhook": "Webhook - Richiesta HTTP",
    "flow.trigger.webhookInfo": "Il workflow si avvia quando viene ricevuta una richiesta HTTP",
    "flow.trigger.webhookPath": "Percorso Webhook",
    "flow.trigger.webhookPathHint": "Percorso URL per ricevere le chiamate webhook"
  }
}
