{
  "$schema": "../../schema/locale.schema.json",
  "locale": "fr",
  "category": "cloud.flow",
  "version": "1.0.0",
  "translations": {
    "flow.branch.condition": "Condition",
    "flow.branch.conditionHint": "Supporte : ==, !=, >, <, >=, <=, contains",
    "flow.branch.conditionPlaceholder": "ex: ${step1.count} > 0",
    "flow.branch.false": "Faux",
    "flow.branch.falseDesc": "Quand la condition est fausse",
    "flow.branch.true": "Vrai",
    "flow.branch.trueDesc": "Quand la condition est vraie",
    "flow.end.addMapping": "Ajouter une sortie",
    "flow.end.info": "Ceci est un noeud terminal - l'execution du flux de travail se termine ici",
    "flow.end.outputMapping": "Mappage des sorties",
    "flow.end.outputMappingHint": "Mapper les variables internes vers la sortie du flux de travail",
    "flow.end.successMessage": "Message de succes",
    "flow.end.successMessagePlaceholder": "Message de completion optionnel",
    "flow.fork.branchCount": "Nombre de branches",
    "flow.fork.branchCountHint": "Toutes les branches s'executent en parallele (2-10)",
    "flow.fork.branches": "Branches de sortie",
    "flow.fork.info": "Toutes les branches demarrent simultanement avec les memes donnees d'entree",
    "flow.join.cancelPending": "Annuler les branches en attente a la completion",
    "flow.join.inputCount": "Nombre d'entrees",
    "flow.join.inputs": "Ports d'entree",
    "flow.join.strategy": "Strategie de jointure",
    "flow.join.strategyAll": "Toutes - Attendre toutes les entrees",
    "flow.join.strategyAllHint": "Attend toutes les entrees avant de continuer",
    "flow.join.strategyAny": "N'importe laquelle - Continuer des qu'une arrive",
    "flow.join.strategyAnyHint": "Continue des qu'une entree arrive",
    "flow.join.strategyFirst": "Premiere - La premiere gagne, annule les autres",
    "flow.join.strategyFirstHint": "La premiere entree gagne, annule les restantes",
    "flow.join.timeout": "Delai d'expiration",
    "flow.join.timeoutHint": "Temps d'attente maximum en millisecondes (1s - 1h)",
    "flow.loop.noTarget": "Aucune cible de boucle definie",
    "flow.loop.target": "Retour a :",
    "flow.loop.targetHint": "Connectez une arete de boucle pour definir le noeud cible",
    "flow.loop.times": "Nombre de boucles",
    "flow.loop.timesHint": "Nombre de repetitions (1-1000)",
    "flow.loop.timesPlaceholder": "10",
    "flow.merge.inputCount": "Nombre d'entrees",
    "flow.merge.inputCountHint": "Ports d'entree dynamiques (2-10)",
    "flow.merge.inputs": "Ports d'entree",
    "flow.merge.strategy": "Strategie de fusion",
    "flow.merge.strategyAll": "Toutes - Collecter toutes les entrees",
    "flow.merge.strategyAllHint": "Collecte toutes les entrees dans un tableau",
    "flow.merge.strategyFirst": "Premiere - La premiere entree gagne",
    "flow.merge.strategyFirstHint": "Utilise la premiere entree arrivee",
    "flow.merge.strategyLast": "Derniere - La derniere entree gagne",
    "flow.merge.strategyLastHint": "Utilise la derniere entree arrivee",
    "flow.subflow.addInput": "Ajouter une entree",
    "flow.subflow.addOutput": "Ajouter une sortie",
    "flow.subflow.executionMode": "Mode d'execution",
    "flow.subflow.inputMapping": "Mappage des entrees",
    "flow.subflow.modeAsync": "Asynchrone - Declencher et oublier",
    "flow.subflow.modeAsyncHint": "Demarre le sous-flux et continue sans attendre",
    "flow.subflow.modeInline": "En ligne - Attendre la completion",
    "flow.subflow.modeInlineHint": "Bloque jusqu'a ce que le sous-flux soit termine, retourne le resultat",
    "flow.subflow.modeSpawn": "Engendrer - Nouvelle execution, obtenir l'ID",
    "flow.subflow.modeSpawnHint": "Cree une nouvelle execution, retourne immediatement l'ID d'execution",
    "flow.subflow.outputMapping": "Mappage des sorties",
    "flow.subflow.timeout": "Delai d'expiration (ms)",
    "flow.subflow.workflowRef": "Reference du flux de travail",
    "flow.subflow.workflowRefHint": "ID ou chemin du flux de travail externe a executer",
    "flow.subflow.workflowRefPlaceholder": "workflow_id ou chemin",
    "flow.switch.addCase": "Ajouter un cas",
    "flow.switch.case": "Cas",
    "flow.switch.cases": "Cas du switch",
    "flow.switch.default": "Defaut",
    "flow.switch.defaultInfo": "Les valeurs non correspondantes vont vers la sortie Defaut",
    "flow.switch.expression": "Expression",
    "flow.switch.expressionHint": "Valeur a comparer avec les cas",
    "flow.switch.expressionPlaceholder": "ex: ${step1.status}",
    "flow.switch.label": "Libelle",
    "flow.switch.labelPlaceholder": "Libelle d'affichage",
    "flow.switch.value": "Valeur",
    "flow.switch.valuePlaceholder": "Valeur a correspondre",
    "flow.trigger.description": "Description",
    "flow.trigger.descriptionPlaceholder": "Description optionnelle de ce declencheur",
    "flow.trigger.eventInfo": "Le flux de travail demarre lorsque l'evenement specifie se produit",
    "flow.trigger.eventName": "Nom de l'evenement",
    "flow.trigger.eventNameHint": "Nom de l'evenement a ecouter",
    "flow.trigger.manualInfo": "Le flux de travail demarre lorsqu'il est declenche manuellement par l'utilisateur",
    "flow.trigger.schedule": "Expression Cron",
    "flow.trigger.scheduleHint": "Format cron standard : minute heure jour mois jour_semaine",
    "flow.trigger.scheduleInfo": "Le flux de travail s'execute automatiquement selon le calendrier",
    "flow.trigger.type": "Type de declencheur",
    "flow.trigger.typeEvent": "Evenement - Ecouter un evenement",
    "flow.trigger.typeManual": "Manuel - Initie par l'utilisateur",
    "flow.trigger.typeSchedule": "Planifie - Base sur cron",
    "flow.trigger.typeWebhook": "Webhook - Requete HTTP",
    "flow.trigger.webhookInfo": "Le flux de travail demarre lorsqu'une requete HTTP est recue",
    "flow.trigger.webhookPath": "Chemin du webhook",
    "flow.trigger.webhookPathHint": "Chemin URL pour recevoir les appels webhook"
  }
}
