{
  "$schema": "../../schema/locale.schema.json",
  "locale": "es",
  "category": "cloud.flow",
  "version": "1.0.0",
  "translations": {
    "flow.branch.condition": "Condición",
    "flow.branch.conditionHint": "Soporta: ==, !=, >, <, >=, <=, contains",
    "flow.branch.conditionPlaceholder": "ej. ${step1.count} > 0",
    "flow.branch.false": "Falso",
    "flow.branch.falseDesc": "Cuando la condición es falsa",
    "flow.branch.true": "Verdadero",
    "flow.branch.trueDesc": "Cuando la condición es verdadera",
    "flow.end.addMapping": "Agregar salida",
    "flow.end.info": "Este es un nodo terminal - la ejecución del flujo de trabajo termina aquí",
    "flow.end.outputMapping": "Mapeo de salida",
    "flow.end.outputMappingHint": "Mapear variables internas a la salida del flujo de trabajo",
    "flow.end.successMessage": "Mensaje de éxito",
    "flow.end.successMessagePlaceholder": "Mensaje de finalización opcional",
    "flow.fork.branchCount": "Número de ramas",
    "flow.fork.branchCountHint": "Todas las ramas se ejecutan en paralelo (2-10)",
    "flow.fork.branches": "Ramas de salida",
    "flow.fork.info": "Todas las ramas se activan simultáneamente con los mismos datos de entrada",
    "flow.join.cancelPending": "Cancelar pendientes al completar",
    "flow.join.inputCount": "Número de entradas",
    "flow.join.inputs": "Puertos de entrada",
    "flow.join.strategy": "Estrategia de unión",
    "flow.join.strategyAll": "Todos - Esperar todas las entradas",
    "flow.join.strategyAllHint": "Espera todas las entradas antes de continuar",
    "flow.join.strategyAny": "Cualquiera - Continuar con cualquier entrada",
    "flow.join.strategyAnyHint": "Continúa cuando llega cualquier entrada",
    "flow.join.strategyFirst": "Primero - El primero gana, cancelar otros",
    "flow.join.strategyFirstHint": "La primera entrada gana, cancela las restantes",
    "flow.join.timeout": "Tiempo de espera",
    "flow.join.timeoutHint": "Tiempo máximo de espera en milisegundos (1s - 1h)",
    "flow.loop.noTarget": "No hay objetivo de bucle establecido",
    "flow.loop.target": "Volver a:",
    "flow.loop.targetHint": "Conecte una arista de bucle para establecer el nodo objetivo",
    "flow.loop.times": "Veces de bucle",
    "flow.loop.timesHint": "Número de veces a repetir (1-1000)",
    "flow.loop.timesPlaceholder": "10",
    "flow.merge.inputCount": "Número de entradas",
    "flow.merge.inputCountHint": "Puertos de entrada dinámicos (2-10)",
    "flow.merge.inputs": "Puertos de entrada",
    "flow.merge.strategy": "Estrategia de fusión",
    "flow.merge.strategyAll": "Todos - Recopilar todas las entradas",
    "flow.merge.strategyAllHint": "Recopila todas las entradas en un arreglo",
    "flow.merge.strategyFirst": "Primero - La primera entrada gana",
    "flow.merge.strategyFirstHint": "Usa la primera entrada que llegue",
    "flow.merge.strategyLast": "Último - La última entrada gana",
    "flow.merge.strategyLastHint": "Usa la última entrada que llegue",
    "flow.subflow.addInput": "Agregar entrada",
    "flow.subflow.addOutput": "Agregar salida",
    "flow.subflow.executionMode": "Modo de ejecución",
    "flow.subflow.inputMapping": "Mapeo de entrada",
    "flow.subflow.modeAsync": "Asíncrono - Disparar y olvidar",
    "flow.subflow.modeAsyncHint": "Inicia el subflujo y continúa sin esperar",
    "flow.subflow.modeInline": "En línea - Esperar finalización",
    "flow.subflow.modeInlineHint": "Bloquea hasta que el subflujo complete, devuelve resultado",
    "flow.subflow.modeSpawn": "Generar - Nueva ejecución, obtener ID",
    "flow.subflow.modeSpawnHint": "Crea nueva ejecución, devuelve ID de ejecución inmediatamente",
    "flow.subflow.outputMapping": "Mapeo de salida",
    "flow.subflow.timeout": "Tiempo de espera (ms)",
    "flow.subflow.workflowRef": "Referencia de flujo de trabajo",
    "flow.subflow.workflowRefHint": "ID o ruta del flujo de trabajo externo a ejecutar",
    "flow.subflow.workflowRefPlaceholder": "workflow_id o ruta",
    "flow.switch.addCase": "Agregar caso",
    "flow.switch.case": "Caso",
    "flow.switch.cases": "Casos de switch",
    "flow.switch.default": "Predeterminado",
    "flow.switch.defaultInfo": "Los valores sin coincidencia van a la salida Predeterminada",
    "flow.switch.expression": "Expresión",
    "flow.switch.expressionHint": "Valor a comparar con los casos",
    "flow.switch.expressionPlaceholder": "ej. ${step1.status}",
    "flow.switch.label": "Etiqueta",
    "flow.switch.labelPlaceholder": "Etiqueta de visualización",
    "flow.switch.value": "Valor",
    "flow.switch.valuePlaceholder": "Valor de coincidencia",
    "flow.trigger.description": "Descripción",
    "flow.trigger.descriptionPlaceholder": "Descripción opcional de este disparador",
    "flow.trigger.eventInfo": "El flujo de trabajo inicia cuando ocurre el evento especificado",
    "flow.trigger.eventName": "Nombre del evento",
    "flow.trigger.eventNameHint": "Nombre del evento a escuchar",
    "flow.trigger.manualInfo": "El flujo de trabajo inicia cuando el usuario lo activa manualmente",
    "flow.trigger.schedule": "Expresión Cron",
    "flow.trigger.scheduleHint": "Formato cron estándar: minuto hora día mes díaSemana",
    "flow.trigger.scheduleInfo": "El flujo de trabajo se ejecuta automáticamente según programación",
    "flow.trigger.type": "Tipo de disparador",
    "flow.trigger.typeEvent": "Evento - Escuchar evento",
    "flow.trigger.typeManual": "Manual - Iniciado por usuario",
    "flow.trigger.typeSchedule": "Programado - Basado en cron",
    "flow.trigger.typeWebhook": "Webhook - Solicitud HTTP",
    "flow.trigger.webhookInfo": "El flujo de trabajo inicia cuando se recibe una solicitud HTTP",
    "flow.trigger.webhookPath": "Ruta de webhook",
    "flow.trigger.webhookPathHint": "Ruta URL para recibir llamadas webhook"
  }
}
